[浅谈什么是动态规划以及相关的「股票」算法题](https://github.com/MisterBooo/LeetCodeAnimation/blob/master/notes/LeetCode%E7%AC%AC123%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.md)

股票类的题目在leetcode中有六个，可以使用同一动态规划的套路来做

## 实战练习

下面的三道算法题都是来源于 LeetCode 上与股票买卖相关的问题 ，我们按照 **动态规划** 的算法流程来处理该类问题。

**股票买卖**这一类的问题，都是给一个输入数组，里面的每个元素表示的是每天的股价，并且你只能持有一支股票（也就是你必须在再次购买前出售掉之前的股票），一般来说有下面几种问法：

- 只能买卖一次
- 可以买卖无数次
- 可以买卖 k 次

需要你设计一个算法去获取最大的利润。

## 

## 买卖股票的最佳时机

题目来源于 LeetCode 上第 121 号问题：买卖股票的最佳时机。题目难度为 Easy，目前通过率为 49.4% 。

### 

### 题目描述

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 

### 题目解析

我们按照动态规划的思想来思考这道问题。

#### 

#### 状态

有 **买入（buy）** 和 **卖出（sell）** 这两种状态。

#### 

#### 转移方程

对于买来说，买之后可以卖出（进入卖状态），也可以不再进行股票交易（保持买状态）。

对于卖来说，卖出股票后不在进行股票交易（还在卖状态）。

只有在手上的钱才算钱，手上的钱购买当天的股票后相当于亏损。也就是说当天买的话意味着损失`-prices[i]`，当天卖的话意味着增加`prices[i]`，当天卖出总的收益就是 `buy+prices[i]` 。

所以我们只要考虑当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高。

- buy = max(buy, -price[i])  （注意：根据定义 buy 是负数）
- sell = max(sell,  prices[i] + buy)

#### 

#### 边界

第一天 `buy = -prices[0]`, `sell = 0`，最后返回 sell 即可。

### 代码实现

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) <= 1:
            return 0
        buy, sell = -prices[0], 0
        for i in range(1, len(prices)):
            buy = max(buy, -prices[i])
            sell = max(sell, prices[i] + buy)
        return sell

```

## 

## 买卖股票的最佳时机 II

题目来源于 LeetCode 上第 122 号问题：买卖股票的最佳时机 II。题目难度为 Easy，目前通过率为 53.0% 。

### 

### 题目描述

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 

### 题目解析

#### 

#### 状态

有 **买入（buy）** 和 **卖出（sell）** 这两种状态。

#### 

#### 转移方程

对比上题，这里可以有无限次的买入和卖出，也就是说 **买入** 状态之前可拥有 **卖出** 状态，所以买入的转移方程需要变化。

- buy = max(buy, sell - price[i])
- sell = max(sell,   buy + prices[i] )

#### 

#### 边界

第一天 `buy = -prices[0]`, `sell = 0`，最后返回 sell 即可。

### 代码实现

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = -prices[0], 0
        for i in range(1, len(prices)):
            buy = max(buy, sell - prices[i])
            sell = max(sell, prices[i] + buy)
        return sell

```

## 

## 买卖股票的最佳时机 III

题目来源于 LeetCode 上第 123 号问题：买卖股票的最佳时机 III。题目难度为 Hard，目前通过率为 36.1% 。

### 

### 题目描述

给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 *两笔* 交易。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```

### 

### 题目解析

这里限制了最多两笔交易。

#### 

#### 状态

有 **第一次买入（fstBuy）** 、 **第一次卖出（fstSell）**、**第二次买入（secBuy）** 和 **第二次卖出（secSell）** 这四种状态。

#### 

#### 转移方程

这里最多两次买入和两次卖出，也就是说 **买入** 状态之前可拥有 **卖出** 状态，**卖出** 状态之前可拥有 **买入** 状态，所以买入和卖出的转移方程都需要变化。

- fstBuy = max(fstBuy ，  -price[i])
- fstSell = max(fstSell，fstBuy + prices[i] )
- secBuy = max(secBuy ，fstSell -price[i]) (受第一次卖出状态的影响)
- secSell = max(secSell ，secBuy + prices[i] )

#### 

#### 边界

- 一开始 `fstBuy = -prices[0]`
- 买入后直接卖出，`fstSell = 0`
- 买入后再卖出再买入，`secBuy - prices[0]`
- 买入后再卖出再买入再卖出，`secSell = 0`

最后返回 secSell 。

### 代码实现

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy1, buy2, sell1, sell2 = -prices[0], -prices[0], 0, 0
        for i in range(1, len(prices)):
            buy1 = max(buy1, -prices[i])
            sell1 = max(sell1, prices[i] + buy1)
            buy2 = max(buy2, sell1 - prices[i])
            sell2 = max(sell2, prices[i] + buy2)
        return sell2

```

## 买卖股票的最佳时机含手续费

题目来源于 LeetCode 上第 714 号问题：买卖股票的最佳时机含手续费  题目难度为 Medium。

### 

### 题目描述

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

注意:

    0 < prices.length <= 50000.
    0 < prices[i] < 50000.
    0 <= fee < 50000.

### 代码实现

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        buy, sell = -prices[0], 0
        for i in range(1, len(prices)):
            buy = max(buy, sell - prices[i])
            sell = max(sell, prices[i] + buy - fee)
        return sell

```

